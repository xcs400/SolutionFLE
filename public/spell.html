<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <title>Prononciation – Comparaison</title>
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      font-family: Arial;
      padding: 16px;
      max-width: 780px;
      margin: 0 auto;
    }

    h2 {
      margin: 0 0 4px 0;
      font-size: 16px;
      color: #333;
    }

    .track {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 14px 16px;
      margin-bottom: 14px;
      background: #fafafa;
    }

    .track.prof {
      border-left: 4px solid #0077ff;
    }

    .track.eleve {
      border-left: 4px solid #ff6600;
    }

    .track-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .wave-wrap {
      position: relative;
      height: 120px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      background: #fff;
    }

    .wave-wrap>div {
      position: absolute;
      inset: 0;
    }

    .wave-wrap canvas.overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .status {
      font-size: 12px;
      color: #888;
      margin-top: 6px;
      min-height: 16px;
    }

    button {
      padding: 9px 18px;
      font-size: 14px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background: #eee;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    button:disabled {
      opacity: .4;
      cursor: default;
    }

    button.rec {
      background: #0077ff;
      color: #fff;
    }

    button.rec.recording {
      background: #ff2222;
    }

    button.play {
      background: #28a745;
      color: #fff;
    }

    #bothBtn {
      display: block;
      width: 100%;
      padding: 13px;
      font-size: 15px;
      background: #6f42c1;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 4px;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    #bothBtn:disabled {
      opacity: .4;
      cursor: default;
    }

    #scoreBox {
      margin-top: 18px;
      padding: 16px 20px;
      border-radius: 8px;
      background: #f0f0f0;
      flex-direction: column;
    }

    .score-top {
      display: flex;
      width: 100%;
      align-items: center;
      gap: 18px;
    }

    #scoreLabel {
      font-size: 14px;
      color: #555;
      flex: 1;
      font-weight: bold;
    }

    #scoreBar {
      width: 100%;
      height: 10px;
      border-radius: 5px;
      background: #ddd;
      margin-top: 8px;
      overflow: hidden;
    }

    #scoreBarFill {
      height: 100%;
      width: 0%;
      border-radius: 5px;
      transition: width .6s ease, background .4s;
    }

    #scorePct {
      font-size: 38px;
      font-weight: bold;
      letter-spacing: -1px;
      transition: color .4s;
    }

    .sub-scores {
      display: flex;
      gap: 15px;
      margin-top: 15px;
      border-top: 1px solid #ddd;
      padding-top: 15px;
      width: 100%;
    }

    .sub-score {
      flex: 1;
      text-align: center;
    }

    .sub-score-val {
      font-size: 22px;
      font-weight: bold;
      margin-bottom: 2px;
    }

    .sub-score-lbl {
      font-size: 11px;
      color: #777;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .legend {
      font-size: 11px;
      color: #666;
      margin-top: 4px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .legend span {
      display: flex;
      align-items: center;
      gap: 3px;
    }

    @media(max-width:480px) {
      button {
        flex: 1;
      }

      #scorePct {
        font-size: 28px;
      }

      .wave-wrap {
        height: 22vw;
        min-height: 80px;
      }
    }
  </style>
  <script src="https://unpkg.com/wavesurfer.js"></script>
  <script src="audio-processor-advanced.js"></script>
</head>

<body>

  <!-- Sélecteur de modes -->
  <div
    style="margin-bottom: 20px; display:flex; gap:20px; background:#fff; padding:15px; border-radius:8px; border:1px solid #ddd; align-items:center;">
    <strong style="white-space:nowrap;">Mode de l'application :</strong>
    <label style="cursor:pointer;"><input type="radio" name="appMode" value="student" checked> 🎓 Entraînement
      (Élève)</label>
    <label style="cursor:pointer;"><input type="radio" name="appMode" value="prof"> 👩‍🏫 Création de leçon
      (Prof)</label>
  </div>

  <!-- Sélecteur de leçons (Mode Eleve) -->
  <div id="lessonSelectorBox"
    style="margin-bottom:20px; padding:15px; background:#eef4ff; border-radius:8px; border:1px dashed #b7cfff; display:flex; flex-direction:column; gap:10px;">
    <strong>Cliquer sur une leçon pour l'étudier :</strong>
    <select id="lessonSelect" style="padding:10px; border-radius:4px; border:1px solid #ccc; font-size:14px;">
      <option value="">-- Chargement des leçons actives --</option>
    </select>
  </div>

  <div class="track prof" id="profTrackWrapper">
    <h2>👩‍🏫 Professeur <span id="profHint" style="font-size:12px; font-weight:normal; color:#666;">(Écoute seulement
        en mode élève)</span></h2>
    <div class="track-controls">
      <button class="rec" id="recProf" disabled>🎤 Parler</button>
      <button class="play" id="playProf" disabled>▶ Écouter</button>
    </div>
    <div class="wave-wrap">
      <div id="waveProf"></div><canvas class="overlay" id="envProf"></canvas>
    </div>
    <div class="status" id="statusProf">⏳ Initialisation…</div>
  </div>

  <!-- Boîte de sauvegarde (Mode Prof) -->
  <div id="saveProfBox"
    style="display:none; margin-bottom:20px; padding:15px; background:#fff3e0; border-radius:8px; border:1px solid #ffcc80; flex-direction:column; gap:10px;">
    <h3 style="margin:0; font-size:16px;">💾 Sauvegarder la leçon (Base de données)</h3>
    <div style="font-size:12px; color:#666;">Pour écraser le son d'une leçon, sélectionnez-la ci-dessous, enregistrez un
      nouveau son, puis sauvegardez. Pour modifier le nom, modifiez-le et sauvegardez.</div>
    <div style="display:flex; gap:10px;">
      <input type="hidden" id="profLessonIdInput" value="">
      <input type="text" id="profLessonInput" placeholder="Ex: Mots finissant par -eur"
        style="flex:1; padding:10px; border:1px solid #ccc; border-radius:4px;">
      <button id="saveProfBtn" style="background:#ff9800; color:#fff; font-weight:bold; cursor:pointer;"
        disabled>Sauvegarder La Leçon</button>
    </div>
    <div id="saveProfStatus" style="font-size:14px; font-weight:bold;"></div>

    <div style="margin-top:15px; border-top:1px solid #ffcc80; padding-top:10px;">
      <h4 style="margin:0 0 10px 0; font-size:14px; color:#ff9800;">Liste de vos leçons</h4>
      <div id="profLessonList" style="display:flex; flex-direction:column; gap:8px; max-height:200px; overflow-y:auto;">
        <span style="color:#888; font-size:12px;">Chargement...</span>
      </div>
    </div>
  </div>

  <div class="track eleve" id="eleveTrackWrapper">
    <h2>🎓 Élève</h2>
    <div class="track-controls">
      <button class="rec" id="recEleve" disabled>🎤 Parler</button>
      <button class="play" id="playEleve" disabled>▶ Écouter</button>
    </div>
    <div class="wave-wrap">
      <div id="waveEleve"></div><canvas class="overlay" id="envEleve"></canvas>
    </div>
    <div class="status" id="statusEleve">⏳ Initialisation…</div>
  </div>

  <div class="legend">
    <span>Intonation syllabe :</span>
    <span style="color:#22aa44">▲ montante</span>
    <span style="color:#cc3333">▼ descendante</span>
    <span style="color:#888">● stable</span>
  </div>

  <div style="display:flex; gap:10px; margin-bottom:15px;">
    <button id="bothBtn" disabled>▶▶ Écouter les deux ensemble</button>
  </div>

  <div id="scoreBox"
    style="display:none; margin-bottom:20px; padding:15px; border-radius:8px; border:1px solid #ddd; background:#fff;">
    <div class="score-top">
      <div style="flex:1">
        <div id="scoreLabel">Score global</div>
        <div id="scoreBar">
          <div id="scoreBarFill"></div>
        </div>
      </div>
      <div id="scorePct">—</div>
    </div>
      <div class="sub-scores">
      <div class="sub-score">
        <div id="subPitchVal" class="sub-score-val">—</div>
        <div class="sub-score-lbl">🎵 Prosodie</div>
      </div>
      <div class="sub-score">
        <div id="subRhythmVal" class="sub-score-val">—</div>
        <div class="sub-score-lbl">🥁 Rythme syllabique</div>
      </div>
      <div class="sub-score">
        <div id="subStressVal" class="sub-score-val">—</div>
        <div class="sub-score-lbl">💪 Accentuation</div>
      </div>
    </div>
  </div>

  <div id="saveEleveBox"
    style="margin-top:20px; padding:15px; background:#f9f9f9; border-radius:8px; border:1px solid #ddd; display:flex; flex-direction:column; gap:10px;">
    <h3 style="margin:0; font-size:16px;">💾 Sauvegarder mon essai</h3>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <input type="text" id="studentInput" placeholder="Prénom de l'élève"
        style="flex:1; padding:10px; border:1px solid #ccc; border-radius:4px;">
    </div>
    <button id="saveEleveBtn" style="background:#28a745; color:#fff; font-weight:bold; cursor:pointer;" disabled>Envoyer
      à mon professeur</button>
    <div id="saveEleveStatus" style="font-size:14px; text-align:center; font-weight:bold;"></div>
  </div>

  <div id="historyBox"
    style="margin-top:20px; padding:15px; background:#fff; border-radius:8px; border:1px solid #ddd;">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <h3 style="margin:0; font-size:16px;">📚 Historique des progrès</h3>
      <button id="refreshHistBtn" style="padding:4px 8px; font-size:12px;">Rafraîchir</button>
    </div>
    <div id="historyList"
      style="margin-top:15px; display:flex; flex-direction:column; gap:10px; max-height:400px; overflow-y:auto;">
    </div>
  </div>

  <script>
    // ═══════════════════════════════════════════════════════════════
    // AUDIO PROCESSOR ADVANCED INSTANCE
    // ═══════════════════════════════════════════════════════════════
    const audioProcessor = new AudioProcessorAdvanced();

    // ═══════════════════════════════════════════════════════════════
    // STORE PARTAGÉ (constantes et variables)
    // ═══════════════════════════════════════════════════════════════

    const store = { prof: null, eleve: null };

    // ═══════════════════════════════════════════════════════════════
    // LISSAGE GAUSSIEN (réutilisé pour le dessin, garder côté client)
    // ═══════════════════════════════════════════════════════════════
    function gaussSmooth(arr, radius) {
      const n = arr.length, r = Math.max(1, Math.round(radius));
      const out = new Float32Array(n);
      for (let i = 0; i < n; i++) {
        let s = 0, w = 0;
        for (let j = Math.max(0, i - r); j <= Math.min(n - 1, i + r); j++) {
          const g = Math.exp(-0.5 * ((j - i) / r) ** 2);
          s += arr[j] * g; w += g;
        }
        out[i] = s / w;
      }
      return out;
    }

    // ═══════════════════════════════════════════════════════════════
    // SCORE PITCH (DTW sur contours mélodiques)
    // ═══════════════════════════════════════════════════════════════
    function resample(arr, n) {
      const out = new Float32Array(n);
      for (let i = 0; i < n; i++) {
        const t = i / (n - 1) * (arr.length - 1);
        const lo = Math.floor(t), hi = Math.min(lo + 1, arr.length - 1);
        out[i] = arr[lo] + (t - lo) * (arr[hi] - arr[lo]);
      }
      return out;
    }

    // SCORE PROSODIE (forme mélodique, indépendant de la hauteur absolue)
    // Z-normalisation → fonctionne cross-genre (voix grave/aiguë)
    // ═══════════════════════════════════════════════════════════════
    function scorePitch(pitchA, pitchB) {
      const toSt = hz => hz > 50 ? 12 * Math.log2(hz / 150) : null;

      const vA = pitchA.frames.map(toSt).filter(v => v !== null);
      const vB = pitchB.frames.map(toSt).filter(v => v !== null);

      // Pénalité voix : si l'élève n'a pas assez de frames voisées → pas de parole réelle
      const vrA = vA.length / (pitchA.frames.length || 1);
      const vrB = vB.length / (pitchB.frames.length || 1);
      const voicedPenalty = Math.min(vrA, vrB) / (Math.max(vrA, vrB) + 1e-10);
      if (vA.length < 5 || vB.length < 5 || vrB < 0.05) return 0;

      // Z-score : retire la moyenne ET normalise la variance
      // → compare la FORME du contour, pas la hauteur absolue
      const znorm = arr => {
        const m = arr.reduce((s, v) => s + v, 0) / arr.length;
        const std = Math.sqrt(arr.reduce((s, v) => s + (v - m) ** 2, 0) / arr.length) || 1;
        return arr.map(v => (v - m) / std);
      };
      const cA = znorm(vA), cB = znorm(vB);

      const N = 80;
      const rA = Array.from(resample(Float32Array.from(cA), N));
      const rB = Array.from(resample(Float32Array.from(cB), N));

      const dtw = Array.from({ length: N + 1 }, () => new Float32Array(N + 1).fill(Infinity));
      dtw[0][0] = 0;
      for (let i = 1; i <= N; i++) for (let j = 1; j <= N; j++) {
        const cost = Math.abs(rA[i - 1] - rB[j - 1]);
        dtw[i][j] = cost + Math.min(dtw[i - 1][j], dtw[i][j - 1], dtw[i - 1][j - 1]);
      }
      const dtwDist = dtw[N][N] / (2 * N);
      const shapeScore = Math.max(0, 1 - dtwDist / 2.0);
      // Pondère par la similarité de taux de voix (pénalise le bruit non voisé)
      return shapeScore * (0.6 + 0.4 * voicedPenalty);
    }

    // SCORE TEMPS FORTS — compare les enveloppes d'énergie (accents, articulation)
    // Mesure si les mêmes syllabes sont accentuées, indépendamment du timbre/genre
    // ═══════════════════════════════════════════════════════════════
    function scoreStress(envA, envB, pitchA, pitchB) {
      if (!envA || !envB) return 0;

      // Vérifie qu'il y a vraiment de la parole voisée chez l'élève
      const countVoiced = frames => frames.filter(f => f > 50).length;
      const vrA = pitchA ? countVoiced(pitchA.frames) / (pitchA.frames.length || 1) : 0;
      const vrB = pitchB ? countVoiced(pitchB.frames) / (pitchB.frames.length || 1) : 0;
      if (vrB < 0.05) return 0; // bruit ou silence → score nul

      const N = 64;
      // Resampler à N buckets et Z-normaliser
      const prep = env => {
        const r = Array.from(resample(Float32Array.from(env), N));
        const m = r.reduce((s, v) => s + v, 0) / N;
        const std = Math.sqrt(r.reduce((s, v) => s + (v - m) ** 2, 0) / N) || 1;
        return r.map(v => (v - m) / std);
      };
      const nA = prep(envA), nB = prep(envB);
      // Corrélation de Pearson (–1..1) → score 0..1
      let num = 0, dA = 0, dB = 0;
      for (let i = 0; i < N; i++) { num += nA[i] * nB[i]; dA += nA[i] ** 2; dB += nB[i] ** 2; }
      const r = (dA > 0 && dB > 0) ? num / Math.sqrt(dA * dB) : 0;
      const corr = Math.max(0, (r + 1) / 2);
      // Pondère par taux de voix élève vs prof
      const voicedPenalty = Math.min(vrA, vrB) / (Math.max(vrA, vrB) + 1e-10);
      return corr * (0.5 + 0.5 * voicedPenalty);
    }

    // ═══════════════════════════════════════════════════════════════
    // SCORE RYTHME (DTW sur IOI normalisés)
    // ═══════════════════════════════════════════════════════════════
    function scoreRhythm(posA, posB) {
      const nA = posA.length, nB = posB.length;
      if (nA === 0 || nB === 0) return 0;

      const countFactor = Math.max(0.60, 1 - Math.abs(nA - nB) / Math.max(nA, nB) * 0.5);
      if (nA < 2 || nB < 2) return 0.20 * countFactor;

      const ioiOf = pos => {
        const ioi = pos.slice(1).map((v, i) => v - pos[i]);
        const sum = ioi.reduce((a, b) => a + b, 0);
        return sum > 0 ? ioi.map(v => v / sum) : ioi;
      };
      const ioiA = ioiOf(posA), ioiB = ioiOf(posB);
      const la = ioiA.length, lb = ioiB.length;
      const dp = Array.from({ length: la + 1 }, () => new Float32Array(lb + 1).fill(Infinity));
      dp[0][0] = 0;
      for (let i = 1; i <= la; i++) for (let j = 1; j <= lb; j++) {
        const cost = Math.abs(ioiA[i - 1] - ioiB[j - 1]);
        dp[i][j] = cost + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
      }
      const dtwDist = dp[la][lb] / Math.max(la, lb);
      const ioiScore = Math.max(0, 1 - dtwDist * 4);
      return ioiScore * countFactor;
    }

    // ═══════════════════════════════════════════════════════════════
    // AFFICHAGE DES SCORES
    // ═══════════════════════════════════════════════════════════════
    function computeAndDisplay() {
      if (!store.prof || !store.eleve) return;

      const pctPitch  = Math.round(scorePitch(store.prof.pitch, store.eleve.pitch) * 100);
      const pctRhythm = Math.round(scoreRhythm(store.prof.syllables, store.eleve.syllables) * 100);
      const pctStress = Math.round(scoreStress(store.prof.envelope, store.eleve.envelope, store.prof.pitch, store.eleve.pitch) * 100);

      // Gate syllabique : pénalise si l'élève n'a détecté aucune syllabe (bruit, silence)
      const nSylProf = store.prof.syllables.length;
      const nSylEleve = store.eleve.syllables.length;
      // Rapport syllabes élève/prof, plafonné à 1, penalise à 0 si 0 syllabes détectées
      const sylGate = nSylProf === 0 ? 1 : Math.min(1, nSylEleve / nSylProf);

      // Poids : prosodie 30% · rythme 35% · temps forts 35%
      const rawGlobal = pctPitch * 0.30 + pctRhythm * 0.35 + pctStress * 0.35;
      const pctGlobal = Math.round(rawGlobal * sylGate);

      document.getElementById('scoreBox').style.display = 'flex';
      const col = v => v >= 75 ? '#28a745' : v >= 50 ? '#fd7e14' : '#dc3545';

      document.getElementById('scorePct').textContent = pctGlobal + ' %';
      document.getElementById('scorePct').style.color = col(pctGlobal);
      document.getElementById('scoreBarFill').style.width = pctGlobal + '%';
      document.getElementById('scoreBarFill').style.background = col(pctGlobal);
      document.getElementById('subPitchVal').textContent = pctPitch + ' %';
      document.getElementById('subPitchVal').style.color = col(pctPitch);
      document.getElementById('subRhythmVal').textContent = pctRhythm + ' %';
      document.getElementById('subRhythmVal').style.color = col(pctRhythm);
      document.getElementById('subStressVal').textContent = pctStress + ' %';
      document.getElementById('subStressVal').style.color = col(pctStress);
      document.getElementById('scoreLabel').textContent =
        pctGlobal >= 75 ? '🎉 Excellente prononciation !'
          : pctGlobal >= 50 ? '👍 Bien, continue à t\'entraîner !'
            : '💪 Écoute bien l\'intonation du professeur';
    }

    // ═══════════════════════════════════════════════════════════════
    // DESSIN : enveloppe + courbe de pitch + marqueurs syllabiques
    // Version optimisée pour AudioProcessorAdvanced
    // ═══════════════════════════════════════════════════════════════
    function drawOverlayFromResult(canvas, envelope, color, intonation, pitchResult) {
      const wrap = canvas.parentElement;
      const W = wrap.clientWidth || 740, H = wrap.clientHeight || 120;
      canvas.width = W; canvas.height = H;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, W, H);

      // ── 1. Enveloppe RMS (déjà normalisée) ────────────────────────
      // Resampler l'enveloppe à W points si nécessaire (N_ENV=512 vs W pixels)
      const envW = envelope.length !== W ? resample(Float32Array.from(envelope), W) : envelope;
      const sm = gaussSmooth(envW, Math.max(3, Math.floor(W * 0.01)));

      const envTop = H * 0.38;
      const envH = H - envTop;
      const scaleY = envH * 0.46;
      const mid = envTop + envH * 0.5;

      const grad = ctx.createLinearGradient(0, envTop, 0, H);
      grad.addColorStop(0, color + '99');
      grad.addColorStop(0.5, color + 'cc');
      grad.addColorStop(1, color + '99');

      // Remplissage enveloppe
      ctx.beginPath();
      ctx.moveTo(0, mid - sm[0] * scaleY);
      for (let i = 1; i < W; i++) {
        const cx = i - .5;
        ctx.bezierCurveTo(cx, mid - sm[i - 1] * scaleY, cx, mid - sm[i] * scaleY, i, mid - sm[i] * scaleY);
      }
      for (let i = W - 1; i >= 0; i--) {
        const cx = i + .5;
        ctx.bezierCurveTo(cx, mid + sm[Math.min(i + 1, W - 1)] * scaleY, cx, mid + sm[i] * scaleY, i, mid + sm[i] * scaleY);
      }
      ctx.closePath();
      ctx.fillStyle = grad; ctx.globalAlpha = .40; ctx.fill();

      // Contour haut enveloppe
      ctx.beginPath();
      ctx.moveTo(0, mid - sm[0] * scaleY);
      for (let i = 1; i < W; i++) {
        const cx = i - .5;
        ctx.bezierCurveTo(cx, mid - sm[i - 1] * scaleY, cx, mid - sm[i] * scaleY, i, mid - sm[i] * scaleY);
      }
      ctx.globalAlpha = .85; ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.stroke();

      // ── 2. Courbe de pitch (zone haute du canvas) ─────────────────
      const { frames, hopSec, totalDur } = pitchResult;
      const pitchTop = 4;
      const pitchBottom = envTop - 6;
      const pitchZoneH = pitchBottom - pitchTop;

      const REF = 150;
      const voicedHz = frames.filter(v => v > 50);
      if (voicedHz.length > 3) {
        const voicedST = voicedHz.map(hz => 12 * Math.log2(hz / REF));
        const minST = Math.min(...voicedST) - 1;
        const maxST = Math.max(...voicedST) + 1;

        const stToY = st => pitchBottom - ((st - minST) / (maxST - minST)) * pitchZoneH;

        // Tracé : connecter univement les frames voisées consécutives
        ctx.beginPath();
        let inLine = false;
        for (let f = 0; f < frames.length; f++) {
          const hz = frames[f];
          if (hz <= 50) { inLine = false; continue; }
          const x = (f * hopSec / totalDur) * W;
          const st = 12 * Math.log2(hz / REF);
          const y = stToY(st);
          if (!inLine) { ctx.moveTo(x, y); inLine = true; }
          else { ctx.lineTo(x, y); }
        }
        ctx.globalAlpha = .90;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.setLineDash([]);
        ctx.stroke();

        // Axe horizontal léger
        ctx.beginPath();
        const midST = (minST + maxST) / 2;
        ctx.moveTo(0, stToY(midST));
        ctx.lineTo(W, stToY(midST));
        ctx.globalAlpha = .12;
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // ── 3. Marqueurs syllabiques + flèche d'intonation ───────────
      ctx.globalAlpha = 1;
      const ARROW_SZ = 7;
      const MARKER_Y = mid - 6;

      for (const { pos, tone, slopeST } of intonation) {
        const x = Math.round(pos * W);

        const arrowColor =
          tone === 'up' ? '#22aa44' :
            tone === 'down' ? '#cc3333' : '#888888';

        ctx.globalAlpha = 0.92;
        ctx.fillStyle = arrowColor;
        ctx.strokeStyle = arrowColor;

        const ix = Math.min(Math.round(pos * W), W - 1);
        const envTop_ = mid - sm[ix] * scaleY - 4;

        if (tone === 'up') {
          ctx.beginPath();
          ctx.moveTo(x, envTop_ - 12);
          ctx.lineTo(x - ARROW_SZ, envTop_);
          ctx.lineTo(x + ARROW_SZ, envTop_);
          ctx.closePath();
          ctx.fill();
        } else if (tone === 'down') {
          ctx.beginPath();
          ctx.moveTo(x, envTop_);
          ctx.lineTo(x - ARROW_SZ, envTop_ - 12);
          ctx.lineTo(x + ARROW_SZ, envTop_ - 12);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.arc(x, envTop_ - 6, ARROW_SZ * 0.7, 0, Math.PI * 2);
          ctx.fill();
        }

        // Petite barre verticale pointillée
        ctx.beginPath();
        ctx.moveTo(x, envTop_ - 14);
        ctx.lineTo(x, pitchBottom);
        ctx.globalAlpha = 0.18;
        ctx.strokeStyle = arrowColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 3]);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      ctx.globalAlpha = 1;
    }

    // ═══════════════════════════════════════════════════════════════
    // USINE DE TRACK
    // ═══════════════════════════════════════════════════════════════
    function makeTrack({ waveId, envId, recId, playId, statusId, color, key }) {
      const wave = WaveSurfer.create({
        container: '#' + waveId, waveColor: color + '55', progressColor: color + '99',
        height: 120, normalize: true,
      });
      const recBtn = document.getElementById(recId);
      const playBtn = document.getElementById(playId);
      const statusEl = document.getElementById(statusId);
      const ovCanvas = document.getElementById(envId);
      let mediaRecorder, audioChunks = [], stream;

      (async () => {
        try {
          stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          statusEl.textContent = '✅ Micro prêt';
          recBtn.disabled = false;
        } catch (e) {
          const isHttp = location.protocol === 'http:' && !['localhost', '127.0.0.1'].includes(location.hostname);
          statusEl.textContent = isHttp ? '❌ HTTP — micro requiert HTTPS'
            : e.name === 'NotAllowedError' ? '❌ Permission refusée'
              : e.name === 'NotFoundError' ? '❌ Aucun micro détecté'
                : '❌ ' + e.name;
          statusEl.style.color = '#c00';
        }
      })();

      recBtn.onpointerdown = e => {
        e.preventDefault(); recBtn.setPointerCapture(e.pointerId);
        audioChunks = [];
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = e => { if (e.data?.size > 0) audioChunks.push(e.data); };
        mediaRecorder.onstop = async () => {
          statusEl.textContent = '🔍 Analyse…';
          const blob = new Blob(audioChunks, { type: 'audio/webm' });

          try {
            // Enregistrement live : trimSilence ACTIVÉ
            const result = await audioProcessor.processAudio(blob, {
              trimSilence: true,
              extractPitch: true,
              detectSyllables: true,
              computeIntonation: true,
              onProgress: (progress) => {
                statusEl.textContent = `🔍 ${progress.stage}...`;
              }
            });

            const { wavBlob, pitchAnalysis, envelope, syllables, intonation } = result;

            store[key] = {
              pitch: pitchAnalysis,
              syllables: syllables.map(s => s.pos),
              envelope,
              blob: wavBlob
            };
            refreshSaveBtn();

            wave.load(URL.createObjectURL(wavBlob));
            wave.once('ready', () => {
              playBtn.disabled = false;
              const tones = intonation.map(s =>
                s.tone === 'up' ? '▲' : s.tone === 'down' ? '▼' : '●'
              ).join(' ');
              statusEl.textContent = `✅ ${syllables.length} syllabe(s) : ${tones || '—'}`;

              drawOverlayFromResult(ovCanvas, envelope, color, intonation, pitchAnalysis);
              refreshBothBtn();
              computeAndDisplay();
            });
          } catch (error) {
            statusEl.textContent = '❌ Erreur analyse: ' + error.message;
            statusEl.style.color = '#c00';
          }
        };
        mediaRecorder.start(100);
        recBtn.classList.add('recording'); recBtn.textContent = '⏺ Enregistrement…';
      };

      const stopRec = () => {
        if (mediaRecorder?.state !== 'recording') return;
        recBtn.classList.remove('recording'); recBtn.textContent = '🎤 Parler';
        setTimeout(() => {
          if (mediaRecorder?.state === 'recording') mediaRecorder.stop();
        }, 350);
      };
      recBtn.onpointerup = stopRec;
      recBtn.onlostpointercapture = stopRec;
      playBtn.onclick = () => { wave.isPlaying() ? wave.pause() : wave.play(); };

      // ─── injectBlob : charge un blob depuis le serveur (déjà traité)
      // alreadyProcessed=true → trimSilence DÉSACTIVÉ pour éviter la double coupe
      const injectBlob = async (blob, { alreadyProcessed = false } = {}) => {
        statusEl.textContent = '🔍 Analyse…';

        try {
          const result = await audioProcessor.processAudio(blob, {
            trimSilence: !alreadyProcessed,   // ← NE PAS re-trimmer si déjà fait côté serveur
            extractPitch: true,
            detectSyllables: true,
            computeIntonation: true,
            onProgress: (progress) => {
              statusEl.textContent = `🔍 ${progress.stage}...`;
            }
          });

          const { wavBlob, pitchAnalysis, envelope, syllables, intonation } = result;

          // Si le processeur ne renvoie pas de wavBlob (trimSilence désactivé), on réutilise le blob source
          const finalBlob = wavBlob || blob;

          store[key] = {
            pitch: pitchAnalysis,
            syllables: syllables.map(s => s.pos),
            envelope,
            blob: finalBlob
          };
          refreshSaveBtn();

          wave.load(URL.createObjectURL(finalBlob));
          wave.once('ready', () => {
            playBtn.disabled = false;
            const tones = intonation.map(s => s.tone === 'up' ? '▲' : s.tone === 'down' ? '▼' : '●').join(' ');
            statusEl.textContent = `✅ ${syllables.length} syllabe(s) : ${tones || '—'}`;
            drawOverlayFromResult(ovCanvas, envelope, color, intonation, pitchAnalysis);
            refreshBothBtn();
            computeAndDisplay();
          });
        } catch (error) {
          statusEl.textContent = '❌ Erreur analyse: ' + error.message;
          statusEl.style.color = '#c00';
        }
      };

      return { wave, recBtn, ready: () => !playBtn.disabled, injectBlob };
    }

    const profTrack = makeTrack({ waveId: 'waveProf', envId: 'envProf', recId: 'recProf', playId: 'playProf', statusId: 'statusProf', color: '#0077ff', key: 'prof' });
    const eleveTrack = makeTrack({ waveId: 'waveEleve', envId: 'envEleve', recId: 'recEleve', playId: 'playEleve', statusId: 'statusEleve', color: '#ff6600', key: 'eleve' });

    // ─── Modes de l'Application ───────────────────────────────────────────────
    let currentMode = 'student'; // 'student' ou 'prof'
    const appModes = document.querySelectorAll('input[name="appMode"]');
    const lessonSelectorBox = document.getElementById('lessonSelectorBox');
    const saveProfBox = document.getElementById('saveProfBox');
    const saveEleveBox = document.getElementById('saveEleveBox');
    const eleveTrackWrapper = document.getElementById('eleveTrackWrapper');
    const profHint = document.getElementById('profHint');

    appModes.forEach(radio => radio.addEventListener('change', (e) => {
      currentMode = e.target.value;
      if (currentMode === 'prof') {
        lessonSelectorBox.style.display = 'none';
        eleveTrackWrapper.style.display = 'none';
        bothBtn.style.display = 'none';
        saveEleveBox.style.display = 'none';
        document.getElementById('scoreBox').style.display = 'none';
        profTrack.recBtn.disabled = false;
        profTrack.recBtn.style.display = 'inline-block';
        profHint.style.display = 'none';
        saveProfBox.style.display = 'flex';
        loadProfLessons();
      } else {
        lessonSelectorBox.style.display = 'flex';
        eleveTrackWrapper.style.display = 'block';
        bothBtn.style.display = 'inline-block';
        saveEleveBox.style.display = 'flex';
        profTrack.recBtn.disabled = true;
        profTrack.recBtn.style.display = 'none';
        profHint.style.display = 'inline';
        saveProfBox.style.display = 'none';
        document.getElementById('profLessonIdInput').value = '';
        document.getElementById('profLessonInput').value = '';
        loadLessons();
      }
      refreshBothBtn();
      refreshSaveBtn();
    }));

    // ─── Lesson Loading (Mode Eleve) ──────────────────────────────────────────
    const lessonSelect = document.getElementById('lessonSelect');

    async function loadLessons() {
      lessonSelect.innerHTML = "<option value=''>-- Chargement --</option>";
      try {
        const res = await fetch('/api/pronunciation/lessons');
        const lessons = await res.json();
        lessonSelect.innerHTML = "<option value=''>-- Sélectionnez une leçon --</option>";
        lessons.forEach(l => {
          const opt = document.createElement('option');
          opt.value = l.audioUrl;
          opt.textContent = l.lessonName;
          lessonSelect.appendChild(opt);
        });
      } catch (e) {
        lessonSelect.innerHTML = "<option value=''>Erreur serveur</option>";
      }
    }

    lessonSelect.addEventListener('change', async (e) => {
      const url = e.target.value;
      if (!url) return;
      document.getElementById('statusProf').textContent = "⬇️ Téléchargement leçon...";
      try {
        const res = await fetch(url);
        const blob = await res.blob();
        if (blob.size === 0) throw new Error("Audio vide");
        // Audio déjà traité côté serveur → pas de re-trim
        await profTrack.injectBlob(blob, { alreadyProcessed: true });
      } catch (err) {
        document.getElementById('statusProf').textContent = "❌ Erreur de chargement: " + err.message;
        document.getElementById('statusProf').style.color = '#c00';
      }
    });

    const bothBtn = document.getElementById('bothBtn');

    function refreshBothBtn() {
      const ready = profTrack.ready() && eleveTrack.ready();
      bothBtn.disabled = !ready;
    }
    bothBtn.onclick = () => { profTrack.wave.play(); eleveTrack.wave.play(); };

    // ─── Save PROF Lesson API ────────────────────────────────────────────────
    const saveProfBtn = document.getElementById('saveProfBtn');
    const profLessonInput = document.getElementById('profLessonInput');
    const profLessonIdInput = document.getElementById('profLessonIdInput');
    const saveProfStatus = document.getElementById('saveProfStatus');
    const profLessonList = document.getElementById('profLessonList');

    async function loadProfLessons() {
      try {
        const res = await fetch('/api/pronunciation/lessons');
        const lessons = await res.json();
        profLessonList.innerHTML = "";
        if (lessons.length === 0) {
          profLessonList.innerHTML = "<span style='color:#888; font-size:12px;'>Aucune leçon pour l'instant.</span>";
          return;
        }
        lessons.forEach(l => {
          const item = document.createElement('div');
          item.style = "display:flex; justify-content:space-between; align-items:center; background:#fff; padding:6px 10px; border-radius:4px; border:1px solid #eee; font-size:13px;";
          item.innerHTML = `
            <strong>${l.lessonName}</strong>
            <div style="display:flex; gap:6px;">
              <button onclick="window.editLesson('${l.id}', '${l.lessonName.replace(/'/g, "\\'")}', '${l.audioUrl}')" style="padding:2px 8px; font-size:11px; cursor:pointer;" title="Sélectionner pour écraser/modifier">✏️ Sélectionner</button>
              <button onclick="window.deleteLesson('${l.id}')" style="padding:2px 8px; font-size:11px; background:#dc3545; color:#fff; border:none; border-radius:3px; cursor:pointer;">🗑️</button>
            </div>
          `;
          profLessonList.appendChild(item);
        });
      } catch (e) {
        profLessonList.innerHTML = "<span style='color:red;'>Erreur serveur.</span>";
      }
    }

    window.editLesson = async function (id, name, url) {
      profLessonIdInput.value = id;
      profLessonInput.value = name;
      saveProfStatus.textContent = "Mode édition: Vous pouvez modifier le nom ou ré-enregistrer l'audio.";
      saveProfStatus.style.color = "blue";
      try {
        if (url) {
          const res = await fetch(url);
          const blob = await res.blob();
          // Audio déjà traité côté serveur → pas de re-trim
          await profTrack.injectBlob(blob, { alreadyProcessed: true });
        }
      } catch (e) { }
    };

    window.deleteLesson = async function (id) {
      if (!confirm("Voulez-vous vraiment supprimer cette leçon pour tous les élèves ?")) return;
      try {
        const res = await fetch('/api/pronunciation/lesson/' + id, { method: 'DELETE' });
        const data = await res.json();
        if (data.success) {
          if (profLessonIdInput.value === id) {
            profLessonIdInput.value = "";
            profLessonInput.value = "";
          }
          loadProfLessons();
        } else { alert("Erreur: " + data.error); }
      } catch (e) { alert("Erreur connexion"); }
    };

    saveProfBtn.onclick = async () => {
      const lessonName = profLessonInput.value.trim();
      const editId = profLessonIdInput.value;
      if (!lessonName) return alert("Veuillez renseigner le nom de la leçon.");

      let confirmMsg = editId ? "Mettre à jour cette leçon ?" : "Sauvegarder cette nouvelle leçon dans la base ?";
      if (!confirm(confirmMsg)) return;

      saveProfBtn.disabled = true;
      saveProfStatus.textContent = "⏳ Sauvegarde...";
      saveProfStatus.style.color = "#888";

      const formData = new FormData();
      formData.append('lessonName', lessonName);
      if (editId) formData.append('id', editId);

      if (store.prof?.blob) {
        formData.append('profAudio', store.prof.blob, 'prof.wav');
      } else if (!editId) {
        return alert("Veuillez enregistrer un son pour une NOUVELLE leçon.");
      }

      try {
        const res = await fetch('/api/pronunciation/lesson', { method: 'POST', body: formData });
        const data = await res.json();
        if (data.success) {
          saveProfStatus.textContent = editId ? "✅ Leçon mise à jour !" : "✅ Leçon créée et sauvegardée !";
          saveProfStatus.style.color = "green";
          profLessonIdInput.value = '';
          profLessonInput.value = '';
          store.prof = {};
          loadProfLessons();
        } else {
          saveProfStatus.textContent = "❌ " + (data.error || "Erreur.");
          saveProfStatus.style.color = "red";
          saveProfBtn.disabled = false;
        }
      } catch (err) {
        saveProfStatus.textContent = "❌ Erreur de connexion.";
        saveProfStatus.style.color = "red";
        saveProfBtn.disabled = false;
      }
    };

    // ─── Save ELEVE Attempt API  ─────────────────────────────────────────────
    const saveEleveBtn = document.getElementById('saveEleveBtn');
    const studentInput = document.getElementById('studentInput');
    const saveEleveStatus = document.getElementById('saveEleveStatus');

    function refreshSaveBtn() {
      if (currentMode === 'prof') {
        const isProfReady = !!store.prof?.blob;
        saveProfBtn.disabled = !isProfReady;
        saveProfBtn.style.opacity = isProfReady ? '1' : '0.5';
      } else {
        const isReady = store.prof?.blob && store.eleve?.blob && lessonSelect.value !== '';
        saveEleveBtn.disabled = !isReady;
        saveEleveBtn.style.opacity = isReady ? '1' : '0.5';
      }
    }

    saveEleveBtn.onclick = async () => {
      const lessonName = lessonSelect.options[lessonSelect.selectedIndex].text;
      const studentName = studentInput.value.trim();

      if (!studentName || !lessonSelect.value) {
        alert("Veuillez choisir une leçon et renseigner votre prénom.");
        return;
      }

      if (!confirm("Voulez-vous envoyer cet essai au professeur ?")) return;

      saveEleveBtn.disabled = true;
      saveEleveStatus.textContent = "⏳ Envoi...";
      saveEleveStatus.style.color = "#888";

      const formData = new FormData();
      formData.append('lessonName', lessonName);
      formData.append('studentName', studentName);
      formData.append('profAudio', store.prof.blob, 'prof.wav');
      formData.append('eleveAudio', store.eleve.blob, 'eleve.wav');

      const scorePct = document.getElementById('scorePct').textContent || "0%";
      const subPitchVal = document.getElementById('subPitchVal').textContent || "0%";
      const subRhythmVal = document.getElementById('subRhythmVal').textContent || "0%";
      formData.append('scores', JSON.stringify({
        global: scorePct.replace('%', ''),
        pitch: subPitchVal.replace('%', ''),
        rhythm: subRhythmVal.replace('%', '')
      }));

      try {
        const res = await fetch('/api/pronunciation/save', { method: 'POST', body: formData });
        const data = await res.json();
        if (data.success) {
          saveEleveStatus.textContent = "✅ Essai sauvegardé avec succès !";
          saveEleveStatus.style.color = "green";
          saveEleveBtn.disabled = true;
          loadHistory();
        } else {
          saveEleveStatus.textContent = "❌ " + (data.error || "Erreur serveur.");
          saveEleveStatus.style.color = "red";
          saveEleveBtn.disabled = false;
        }
      } catch (err) {
        saveEleveStatus.textContent = "❌ Erreur de connexion.";
        saveEleveStatus.style.color = "red";
        saveEleveBtn.disabled = false;
      }
    };

    // ─── History UI ───────────────────────────────────────────────────────────
    const historyList = document.getElementById('historyList');
    const refreshHistBtn = document.getElementById('refreshHistBtn');

    async function loadHistory() {
      historyList.innerHTML = "<div style='color:#888;'>Chargement...</div>";
      try {
        const res = await fetch('/api/pronunciation/history');
        const items = await res.json();

        if (items.length === 0) {
          historyList.innerHTML = "<div style='color:#888;'>Aucun historique.</div>";
          return;
        }

        historyList.innerHTML = "";
        items.forEach(item => {
          const date = new Date(item.timestamp).toLocaleString();
          const pScore = item.scores?.pitch || '?';
          const rScore = item.scores?.rhythm || '?';
          const gScore = item.scores?.global || '?';

          const card = document.createElement('div');
          card.style.border = "1px solid #eaeaea";
          card.style.padding = "10px";
          card.style.borderRadius = "6px";
          card.style.background = "#fafafa";
          card.innerHTML = `
            <div style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <strong style="color:#0056b3;">${item.studentName} — ${item.lessonName}</strong>
              <span style="font-size:11px; color:#888;">${date}</span>
            </div>
            <div style="font-size:12px; margin-bottom:8px;">
              Score: <strong>${gScore}%</strong> (Mélodie: ${pScore}% | Rythme: ${rScore}%)
            </div>
            <div style="display:flex; gap:8px;">
              <button onclick="window.playAudio('${item.profAudio}')" style="flex:1; padding:4px; font-size:12px; background:#fff; border:1px solid #ccc;">▶ Écouter Prof</button>
              <button onclick="window.playAudio('${item.eleveAudio}')" style="flex:1; padding:4px; font-size:12px; background:#fff; border:1px solid #ccc;">▶ Écouter Élève</button>
            </div>
            <div style="display:flex; gap:8px; margin-top:8px;">
              <button onclick="window.loadHistoryToGraph('${item.profAudio}', '${item.eleveAudio}')" style="flex:2; padding:4px; font-size:12px; background:#0077ff; color:white; border:none; border-radius:3px; outline:none; cursor:pointer;">📊 Afficher les courbes</button>
              <button onclick="window.deleteHistory('${item.id}')" style="flex:1; padding:4px; font-size:12px; background:#dc3545; color:white; border:none; border-radius:3px; outline:none; cursor:pointer;">🗑️ Supprimer</button>
            </div>
          `;
          historyList.appendChild(card);
        });
      } catch (e) {
        historyList.innerHTML = "<div style='color:red;'>Erreur chargement.</div>";
      }
    }

    refreshHistBtn.onclick = loadHistory;

    window.playAudio = function (url) {
      if (!url || url === 'undefined' || url === 'null') return alert("Fichier introuvable.");
      const a = new Audio(url);
      a.play().catch(e => alert("Impossible de lire l'audio : " + e.message));
    };

    window.deleteHistory = async function (id) {
      if (!confirm("Voulez-vous vraiment supprimer cet essai de l'historique ?")) return;
      try {
        const res = await fetch('/api/pronunciation/history/' + id, { method: 'DELETE' });
        const data = await res.json();
        if (data.success) {
          loadHistory();
        } else {
          alert('Erreur: ' + (data.error || 'inconnue'));
        }
      } catch (e) {
        alert('Erreur connexion');
      }
    };

    window.loadHistoryToGraph = async function (profUrl, eleveUrl) {
      document.getElementById('statusProf').textContent = "⬇️ Chargement de l'essai (Prof)...";
      document.getElementById('statusEleve').textContent = "⬇️ Chargement de l'essai (Eleve)...";
      try {
        if (profUrl && profUrl !== 'null' && profUrl !== 'undefined') {
          const resP = await fetch(profUrl);
          const blobP = await resP.blob();
          // Audio déjà traité côté serveur → pas de re-trim
          await profTrack.injectBlob(blobP, { alreadyProcessed: true });
        }
        if (eleveUrl && eleveUrl !== 'null' && eleveUrl !== 'undefined') {
          const resE = await fetch(eleveUrl);
          const blobE = await resE.blob();
          // Audio déjà traité côté serveur → pas de re-trim
          await eleveTrack.injectBlob(blobE, { alreadyProcessed: true });
        }
      } catch (err) {
        alert("Erreur de chargement: " + err.message);
      }
    };

    // Load history at startup
    loadHistory();

    // ═══════════════════════════════════════════════════════════════
    // UTILITAIRES AUDIO
    // ═══════════════════════════════════════════════════════════════
    async function trimSilence(blob) {
      const audioCtx = new AudioContext();
      const decoded = await audioCtx.decodeAudioData(await blob.arrayBuffer());
      const sr = decoded.sampleRate;
      const nCh = decoded.numberOfChannels;
      const N = decoded.length;

      const mono = new Float32Array(N);
      for (let c = 0; c < nCh; c++) {
        const d = decoded.getChannelData(c);
        for (let i = 0; i < N; i++) mono[i] += d[i] / nCh;
      }

      const winLen = Math.max(1, Math.floor(ONSET_WIN_SEC * sr));
      const nFrames = Math.ceil(N / winLen);
      const rms = new Float32Array(nFrames);
      for (let f = 0; f < nFrames; f++) {
        const off = f * winLen;
        let sum = 0, cnt = 0;
        for (let i = off; i < Math.min(off + winLen, N); i++, cnt++) sum += mono[i] ** 2;
        rms[f] = Math.sqrt(sum / (cnt || 1));
      }

      const noiseFrames = rms.slice(0, Math.max(4, Math.floor(nFrames * 0.20)));
      const sorted = Float32Array.from(noiseFrames).sort();
      const noiseFloor = sorted[Math.floor(sorted.length * 0.75)];
      const dynThresh = Math.max(SILENCE_THRESH, noiseFloor * 4);

      let onsetFrame = -1;
      for (let f = 0; f < nFrames - ONSET_CONFIRM; f++) {
        let ok = true;
        for (let k = 0; k < ONSET_CONFIRM; k++) {
          if (rms[f + k] < dynThresh) { ok = false; break; }
        }
        if (ok) { onsetFrame = f; break; }
      }

      if (onsetFrame < 0) onsetFrame = 0;

      const onsetSample = onsetFrame * winLen;
      const start = Math.max(0, onsetSample - Math.round(PRE_SPEECH_SEC * sr));

      let endFrame = nFrames - 1;
      for (let f = nFrames - 1; f >= 0; f--) {
        if (rms[f] >= dynThresh) { endFrame = f; break; }
      }
      const end = Math.min(N - 1, (endFrame + 1) * winLen + Math.round(TAIL_SEC * sr));

      const newLen = end - start + 1;
      const buf = audioCtx.createBuffer(nCh, newLen, sr);
      for (let c = 0; c < nCh; c++) {
        buf.copyToChannel(decoded.getChannelData(c).slice(start, end + 1), c);
      }
      audioCtx.close();
      return { wav: bufferToWav(buf), buffer: buf };
    }

    function bufferToWav(buffer) {
      const nCh = buffer.numberOfChannels, sr = buffer.sampleRate, len = buffer.length;
      const pcm = new Int16Array(len * nCh);
      for (let i = 0; i < len; i++) for (let c = 0; c < nCh; c++) {
        const s = buffer.getChannelData(c)[i];
        pcm[i * nCh + c] = Math.max(-32768, Math.min(32767, Math.round(s * 32767)));
      }
      const db = pcm.byteLength, wav = new ArrayBuffer(44 + db), v = new DataView(wav);
      const w = (o, s) => [...s].forEach((c, i) => v.setUint8(o + i, c.charCodeAt(0)));
      w(0, 'RIFF'); v.setUint32(4, 36 + db, true); w(8, 'WAVE'); w(12, 'fmt ');
      v.setUint32(16, 16, true); v.setUint16(20, 1, true); v.setUint16(22, nCh, true);
      v.setUint32(24, sr, true); v.setUint32(28, sr * nCh * 2, true);
      v.setUint16(32, nCh * 2, true); v.setUint16(34, 16, true);
      w(36, 'data'); v.setUint32(40, db, true);
      new Uint8Array(wav, 44).set(new Uint8Array(pcm.buffer));
      return new Blob([wav], { type: 'audio/wav' });
    }

    // ─── Initialisation au chargement ──────────────────────────────────────────
    appModes[0].dispatchEvent(new Event('change'));

    // Cleanup au déchargement
    window.addEventListener('beforeunload', () => {
      audioProcessor.dispose();
    });
  </script>
</body>

</html>